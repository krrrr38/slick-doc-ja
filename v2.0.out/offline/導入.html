<!DOCTYPE html SYSTEM "about:legacy-compat">
<html manifest="pamflet.manifest">
      <head>
        <title>slick-doc-ja 2.0 — 導入</title>
        
        <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/blueprint/grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print"/> 
        <!--[if lt IE 8]>
          <link rel="stylesheet" href={ relativeBase + "css/blueprint/ie.css" } type="text/css" media="screen, projection"/>
        <![endif]-->
        <link rel="stylesheet" href="css/pamflet.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/pamflet-print.css" type="text/css" media="print"/>
        <link rel="stylesheet" href="css/pamflet-grid.css" type="text/css" media="screen and (min-device-width: 800px), projection"/>
        <link rel="stylesheet" href="css/color_scheme-redmond.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-github.css" type="text/css" media="screen, projection"/>
        <link rel="stylesheet" href="css/color_scheme-monokai.css" type="text/css" media="screen, projection"/>
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery.collapse.js"></script>
        <script type="text/javascript" src="js/pamflet.js"></script>
        <script type="text/javascript">
          Pamflet.page.language = 'en';
        </script>
        <script type="text/javascript" src="js/prettify/prettify.js"></script><script type="text/javascript" src="js/prettify/lang-scala.js"></script><link type="text/css" rel="stylesheet" href="css/prettify.css"/><script type="text/javascript"><!--
        window.onload=function() { prettyPrint(); };
      --></script>
        
        <meta charset="utf-8"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
        
        
      </head>
      <body class="color_scheme-redmond">
        <a class="page prev nav" href="slick-doc-ja+2.0.html">
            <span class="space">&nbsp;</span>
            <span class="flip">❧</span>
          </a><a class="page next nav" href="%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86.html">
            <span class="space">&nbsp;</span>
            <span>❧</span>
          </a>
        <div class="container">
          <div class="span-16 prepend-1 append-1">
            <div class="span-16 top nav">
              <div class="span-16 title">
                <span>slick-doc-ja 2.0</span> — 導入
              </div>
            </div>
          </div>
          <div class="span-16 prepend-1 append-1 contents">
            <p>Slick 2.0.0 documentation - 01 導入(Introduction)
<!-- Introduction -->
<a href="http://slick.typesafe.com/doc/2.0.0/introduction.html">Permalink to Introduction — Slick 2.0.0 documentation</a>
</p><h1 id="%E5%B0%8E%E5%85%A5">導入<a href="#%E5%B0%8E%E5%85%A5" class="header-link"><span class="header-link-content">&nbsp;</span></a></h1><h2 id="Slick%E3%81%A8%E3%81%AF">Slickとは<a href="#Slick%E3%81%A8%E3%81%AF" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><!-- What is Slick -->
<p>Slickは<a href="http://www.typesafe.com">Typesafe社</a>によって開発が行われている、Scalaのためのモダンなデータベースラッパーである。データベースにアクセスしながらScalaのコレクションを扱うかのようにデータを操作する事が出来る。また、SQLを直接書く事も可能である。
</p><!--Slick is Typesafe‘s modern database query and access library for Scala. It allows you to work with stored data almost as if you were using Scala collections while at the same time giving you full control over when a database access happens and which data is transferred. You can also use SQL directly.-->
<pre><code class="prettyprint lang-scala">val limit = 10.0
// クエリはこのように書く事が出来る
( for( c &lt;- Coffees; if c.price &lt; limit ) yield c.name ).list
// SQLを直接書いた例
sql&quot;select name from coffees where price &lt; $limit&quot;.as[String].list
</code></pre><p>クエリをSQLを用いて書く代わりにScalaを用いるとコンパイル時に合成が安全に行われ、より良い形で利用する事が出来る。Slickは独自のクエリコンパイラを用いてDBに対しクエリを発行する。
</p><!--When using Scala instead of SQL for your queries you profit from the compile-time safety(何これ) and compositionality. Slick can generate queries for different backends including your own, using its extensible query compiler. -->
<p>すぐにSlickを試したいのなら、<a href="http://typesafe.com/activator">Typesafe Activator</a>にある<a href="http://typesafe.com/activator/template/hello-slick">Hello Slick</a>テンプレートを使うと良い。
</p><!-- Get started learning Slick in minutes using the [Hello Slick](http://typesafe.com/activator/template/hello-slick) template in[Typesafe Activator](http://typesafe.com/activator).-->
<h2 id="Slick%E3%81%AE%E7%89%B9%E5%BE%B4">Slickの特徴<a href="#Slick%E3%81%AE%E7%89%B9%E5%BE%B4" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><!-- Features -->
<h3 id="Scala">Scala<a href="#Scala" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>クエリ、テーブル、カラムの操作は全て生のScalaに依るものだ
<!-- -   Queries, Table & Column Mappings, and types are plain Scala-->
</li></ul><pre><code class="prettyprint lang-scala">class Coffees(tag: Tag) extends Table[(String, Double)](tag, &quot;COFFEES&quot;) {
  def name = column[String](&quot;COF_NAME&quot;, O.PrimaryKey)
  def price = column[Double](&quot;PRICE&quot;)
  def * = (name, price)
}
val coffees = TableQuery[Coffees]
</code></pre><ul><li>Scalaのコレクションかのようにデータリソースを扱う事が出来る
<!-- -   Data access APIs similar to Scala collections-->
</li></ul><pre><code class="prettyprint lang-scala">// name というカラムを返すクエリ
coffees.map(_.name)
// 価格が 10.0 未満という条件を用いたクエリ
coffees.filter(_.price &lt; 10.0)
</code></pre><h3 id="Type+Safe">Type Safe<a href="#Type+Safe" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>IDEがコードを書く手助けをしてくれるだろう
<!-- -   Let your IDE help you write your code-->
</li><li>実行時でなくコンパイル時に問題を発見出来る
<!-- -   Find problems at compile-time instead of at runtime-->
</li></ul><pre><code class="prettyprint lang-scala">// `select PRICE from COFFEES` の結果はSeq[Double]になる
// これは型安全な処理が行なわれるためである
val coffeeNames: Seq[Double] = coffees.map(_.price).list
// クエリを作るのも型安全に行なわれる
coffees.filter(_.price &lt; 10.0)
// もし条件の中で異なる型が比較されていたのなら、コンパイルエラーになる
</code></pre><h3 id="Composable">Composable<a href="#Composable" class="header-link"><span class="header-link-content">&nbsp;</span></a></h3><ul><li>クエリは合成・再利用可能な関数となる
<!-- -   Queries are functions that can be composed and reused-->
</li></ul><pre><code class="prettyprint lang-scala">// 10.0 未満の価格で、名前順にソートしたコーヒーの名前を取り出すクエリを作る
coffees.filter(_.price &lt; 10.0).sortBy(_.name).map(_.name)
// ここで作られるSQLは次のものと等価になる
// select name from COFFEES where PRICE &lt; 10.0 order by NAME
</code></pre><h2 id="Compatibility">Compatibility<a href="#Compatibility" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p>SlickはScalaのバージョン2.10が必要になる。（もし2.9以下で使いたいなら<a href="http://scalaquery.org/">ScalaQuery</a>を使うと良い）
</p><!-- Slick requires Scala 2.10. (For Scala 2.9 please use ScalaQuery, thepredecessor of Slick).-->
<h2 id="%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9">サポートするデータベース<a href="#%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><ul><li>DB2 (via <a href="http://slick.typesafe.com/doc/2.0.0/extensions.html">slick-extensions</a>)
</li><li>Derby/JavaDB
</li><li>H2
</li><li>HSQLDB/HyperSQL
</li><li>Microsoft Access
</li><li>Microsoft SQL Server (via <a href="http://slick.typesafe.com/doc/2.0.0/extensions.html">slick-extensions</a>)
</li><li>MySQL
</li><li>Oracle (via <a href="http://slick.typesafe.com/doc/2.0.0/extensions.html">slick-extensions</a>)
</li><li>PostgreSQL
</li><li>SQLite
</li></ul><p>他のSQLデータベースもSlickなら簡単にアクセスする事が出来るでしょう。独自のSQLベースのバックエンドを持つデータベースも、プラグインを作成する事でSlickを利用することが出来ます。そのようなプラグインの作成は大きな貢献となるでしょう。
NoSQLのような他のバックエンドを持つようなデータベースに関しては現在開発中であるため、まだ利用する事はできません。
</p><!--Other SQL databases can be accessed right away with a reduced feature set. Writing a fully featured plugin for your own SQL-based backend can be achieved with a reasonable amount of work. Support for other backends (like NoSQL) is under development but not yet available.-->
<h2 id="License">License<a href="#License" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><blockquote><p>Slick is released under a BSD-Style free and open source software
<a href="https://github.com/slick/slick/blob/2.0.0/LICENSE.txt">license</a>. See the chapter on the commercial
<a href="http://slick.typesafe.com/doc/2.0.0/extensions.html">Slick Extensions</a> add-on package for details on licensing
the Slick drivers for the big commercial database systems.
</p></blockquote><h2 id="Query+APIs">Query APIs<a href="#Query+APIs" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><em>Lifted Embedding</em> は型安全なクエリや更新が行えるSlickの基本的なAPIである。<a href="http://slick.typesafe.com/doc/2.0.0/gettingstarted.html">Getting Started</a>では <em>Lifted Embedding</em> を用いた例を紹介する。
</p><!-- The *Lifted Embedding* is the standard API for type-safe queries and updates in Slick. Please see gettingstarted for an introduction. Most of this user manual focuses on the *Lifted Embedding*.-->
<p>SQL文を直接発行したい場合には、<a href="http://slick.typesafe.com/doc/2.0.0/sql.html">Plain SQL</a> API を利用することが出来る。
</p><!-- For writing your own SQL statements you can use the Plain SQL\<sql\> API.-->
<p><a href="http://slick.typesafe.com/doc/2.0.0/direct-embedding.html"><em>Direct Embedding</em></a>はまだ実験的なものではあるが、<em>Lifted Embedding</em>に替わりとして利用出来る。
</p><!-- The experimental Direct Embedding \<direct-embedding\> is available as an alternative to the *Lifted Embedding*.-->
<h2 id="Lifted+Embedding">Lifted Embedding<a href="#Lifted+Embedding" class="header-link"><span class="header-link-content">&nbsp;</span></a></h2><p><em>Lifted Embedding</em>という名前は基本的なScalaの型を用いるのではなく、 <a href="http://slick.typesafe.com/doc/2.0.0/api/#scala.slick.lifted.Rep">Rep</a>型へと<em>持ち上げ(lifted)</em>されたものを用いるという事に基づいている。これはScalaのコレクションを操作する例と比べると明らかだろう。
</p><!-- The name *Lifted Embedding* refers to the fact that you are not working with standard Scala types (as in the direct embedding \<direct-embedding\>) but with types that are *lifted* into a scala.slick.lifted.Rep type constructor. This becomes clear when you compare the types of a simple Scala collections example -->
<pre><code class="prettyprint lang-scala">case class Coffee(name: String, price: Double)
val coffees: List[Coffee] = //...
...
val l = coffees.filter(_.price &gt; 8.0).map(_.name)
//                       ^       ^          ^
//                       Double  Double     String
</code></pre><p>… Lifted Embeddingを用いる際には次のように書ける
</p><!-- ... with the types of similar code using the lifted embedding:-->
<pre><code class="prettyprint lang-scala">class Coffees(tag: Tag) extends Table[(String, Double)](tag, &quot;COFFEES&quot;) {
  def name = column[String](&quot;COF_NAME&quot;)
  def price = column[Double](&quot;PRICE&quot;)
  def * = (name, price)
}
val coffees = TableQuery[Coffees]
...
val q = coffees.filter(_.price &gt; 8.0).map(_.name)
//                       ^       ^          ^
//               Rep[Double]  Rep[Double]  Rep[String]
</code></pre><p>全ての型は<strong>Rep</strong>へと昇華される。カラムの型である<strong>Coffees</strong>も同様に<code>Rep[(String, Double)]</code>へと昇華されている。数値リテラルである<code>8.0</code>も自動的に<code>Rep[Double]</code>へと昇華する。これは条件式<code>&gt;</code>の左辺が<code>Rep[Double]</code>であることから、右辺には暗黙的な変換が行われるためである。生のScalaの型や値を用いることは、SQLへの変換を行う上で充分な情報を提供しない。これらの変換はそのために行なわれるのである。
</p><!-- All plain types are lifted into **Rep**. The same is true for the table -->
<!-- row type **Coffees** which is a subtype of `Rep[(String, Double)]`. Even -->
<!-- the literal `8.0` is automatically lifted to a `Rep[Double]` by an -->
<!-- implicit conversion because that is what the `>` operator on -->
<!-- `Rep[Double]` expects for the right-hand side. This lifting is necessary -->
<!-- because the lifted types allow us to generate a syntax tree that -->
<!-- captures the query computations. Getting plain Scala functions and -->
<!-- values would not give us enough information for translating those -->
<!-- computations to SQL. -->
<div class="bottom nav span-16">
                        <em>Next Page</em>
                        <span class="arrow">❧</span>
                        <a href="%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86.html"> 始めよう </a>                        
                        
                      </div><div class="tocwrapper show">
      <a class="tochead nav" style="display: none" href="#toc">❦</a>
      <a name="toc"></a>
      <h4 class="toctitle">Contents</h4>
      <div class="tocbody">
      <div><a href="slick-doc-ja+2.0.html">slick-doc-ja 2.0</a></div><ol class="toc"> <li><div class="current">導入</div></li><li><div><a href="%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86.html">始めよう</a></div></li><li><div><a href="Slick+v2.0+Migration+Guide.html">Slick v2.0 Migration Guide</a></div></li><li><div><a href="Connections+%2F+Transactions.html">Connections / Transactions</a></div></li><li><div><a href="Schema+code+generation.html">Schema code generation</a></div></li><li><div><a href="Schemas.html">Schemas</a></div></li><li><div><a href="Queries.html">Queries</a></div></li><li><div><a href="User-Defined+Features.html">User-Defined Features</a></div></li><li><div><a href="Plain+SQL+Queries.html">Plain SQL Queries</a></div></li><li><div><a href="Slick+Extensions.html">Slick Extensions</a></div></li><li><div><a href="Direct+Embedding+%28Experimental+Feature%29.html">Direct Embedding (Experimental Feature)</a></div></li><li><div><a href="Slick+TestKit.html">Slick TestKit</a></div></li><li class="generated"><div><a href="Contents+in+Depth.html">Contents in Depth</a></div></li><li class="generated"><div><a href="Combined+Pages.html">Combined Pages</a></div></li> </ol></div></div>
          </div>
        </div>
        
        
      </body>
    </html>